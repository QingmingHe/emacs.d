#+TITLE: Starter Kit Fortran
#+OPTIONS: toc:nil num:nil ^:nil

* Starter Kit Fortran

Fortran is a major language for scientific computation but a minor for other.

** Fortran configuration
#+BEGIN_SRC emacs-lisp
(defun my-f90-config ()
  (modify-syntax-entry ?_ "w")
  (f90-backslash-not-special)
  (setq-local er/try-expand-list
              (append er/try-expand-list
                      '(f90-mark-block)))
  (setq prettify-symbols-alist
        '(("/=" . ?≠)
          (">=" . ?≥)
          ("<=" . ?≤)))
  (prettify-symbols-mode 1)
  (evil-define-key 'normal f90-mode-map
    "J" 'my-f90-join-lines))

(eval-after-load "f90"
  `(progn
     (require 'expand-region)
     (add-hook 'f90-mode-hook 'my-f90-config)))

(defun my-fortran-config ()
  (evil-define-key 'normal fortran-mode-map
    "J" 'my-fortran-join-lines))

(with-eval-after-load 'fortran
  (add-hook 'fortran-mode-hook 'my-fortran-config))
#+END_SRC

** Fortran indent

Default indentation for Fortran is not that friendly.
#+BEGIN_SRC emacs-lisp
(setq fortran-do-indent 2)
(setq fortran-if-indent 2)
(setq fortran-structure-indent 2)
(setq fortran-continuation-indent 2)
(setq f90-do-indent 2)
(setq f90-if-indent 2)
(setq f90-structure-indent 2)
(setq f90-continuation-indent 2)
(setq f90-type-indent 2)
#+END_SRC

** Declaration align

Align variable declaration. Key binding is *C-c C-i*.

#+BEGIN_SRC emacs-lisp
(defun my-f90-align-declare ()
  "Align declaration of Fortran variables. The declaration before align
should have \"::\" and \"!\". Declaration like these are valid:

integer :: i ! an integer
type(SomeType) :: atype ! object of SomeType"
  (interactive)
  (let ((begin (region-beginning))
        (end (region-end)))
    (indent-region begin end)
    (align-regexp begin end "\\(\\s-*\\)::" 1 1 nil)
    (align-regexp begin end "::\\(\\s-*\\)" 1 1 nil)
    (align-regexp begin end "\\(\\s-*\\)!" 1 1 nil)))
(eval-after-load "f90"
  `(define-key f90-mode-map (kbd "C-c C-i") 'my-f90-align-declare))
#+END_SRC

** Fortran join lines

#+BEGIN_SRC emacs-lisp
(defun my-f90-join-lines ()
  (interactive)
  (if (region-active-p)
      (let* ((beg (region-beginning))
             (end (region-end))
             (nlines (1- (count-lines beg end)))
             arg)
        (when (= beg (point))
          (setq arg t))
        (dotimes (var nlines)
          (f90-join-lines arg)))
    (f90-join-lines t)))

(defun my-fortran-join-lines ()
  (interactive)
  (fortran-join-line -1))
#+END_SRC

** Down case Fortran buffer

#+begin_src emacs-lisp
(defun fortran-downcase-buffer ()
  "Down case all words in current buffer in `fortran-mode'. Let words in
comment and string untouched."
  (interactive)
  (if (eq major-mode 'fortran-mode)
      (save-excursion
        (goto-char (point-min))
        (while (not (eobp))
          (forward-word)
          (let ((sp (syntax-ppss)))
            (unless (or
                     (nth 3 sp)
                     (nth 4 sp))
              (downcase-word -1)))))
    (error "Current buffer is not fortran-mode!")))
#+end_src

** F90 expand region

#+begin_src emacs-lisp
(defun f90-mark-block ()
  (interactive)
  (let (reach-beg reach-end)
    (setq reach-beg (f90-reach-beg-of-block))
    (if (region-active-p)
        (progn
          (exchange-point-and-mark)
          (setq reach-end (f90-reach-end-of-block))
          (exchange-point-and-mark))
      (setq reach-end (f90-reach-end-of-block)))
    (unless (region-active-p)
      (set-mark (point)))
    (cond ((and reach-beg reach-end)
           (exchange-point-and-mark)
           (f90-end-of-block)
           (exchange-point-and-mark)
           (f90-beginning-of-block))
          ((and reach-beg (not reach-end))
           (exchange-point-and-mark)
           (f90-end-or-next-block)
           (exchange-point-and-mark))
          ((and (not reach-beg) reach-end)
           (f90-beg-or-prev-block))
          (t
           (f90-beg-or-prev-block)
           (exchange-point-and-mark)
           (f90-end-or-next-block)
           (exchange-point-and-mark)))))

(defun f90-reach-beg-of-block ()
  (interactive)
  (and
   (looking-at
    (format "\\([a-zA-Z0-9_]+[ \t]*:[ \t]*\\)?%s" f90-blocks-re))
   (looking-back "^[ \t]*")))

(defun f90-reach-end-of-block ()
  (interactive)
  (and
   (looking-at "[ \t]*$")
   (looking-back
    (format "end[ \t]*%s\\([ \t]+[a-zA-Z0-9_]+\\)?" f90-blocks-re))))

(defun f90-beg-or-prev-block ()
  (interactive)
  (cond ((f90-reach-beg-of-block)
         (f90-beginning-of-block))
        ((save-excursion
           (beginning-of-line)
           (looking-at
            (format "[ \t]*\\([a-zA-Z0-9_]+[ \t]*:[ \t]*\\)?%s" f90-blocks-re)))
         (back-to-indentation))
        (t
         (f90-beginning-of-block))))

(defun f90-end-or-next-block ()
  (interactive)
  (cond ((f90-reach-end-of-block)
         (f90-end-of-block))
        ((save-excursion
           (beginning-of-line)
           (looking-at (format "[ \t]*end[ \t]*%s" f90-blocks-re)))
         (end-of-line))
        (t
         (f90-end-of-block))))
#+end_src
