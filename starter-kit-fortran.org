#+TITLE: Starter Kit Fortran
#+OPTIONS: toc:nil num:nil ^:nil

* Starter Kit Fortran

Fortran is a major language for scientific computation but a minor for other.

** Fortran config
#+BEGIN_SRC emacs-lisp
(defun my-f90-config ()
  (modify-syntax-entry ?_ "w")
  (f90-backslash-not-special)
  (setq-local er/try-expand-list
              (append er/try-expand-list
                      '(f90-mark-block)))
  (when (> emacs-minor-version 3)
    (setq prettify-symbols-alist
          '(("/=" . ?≠)
            (">=" . ?≥)
            ("<=" . ?≤)))
    (prettify-symbols-mode 1)))
(eval-after-load "f90"
  `(add-hook 'f90-mode-hook 'my-f90-config))
#+END_SRC

** Fortran indent

Default indentation for Fortran is not that friendly.
#+BEGIN_SRC emacs-lisp
(setq fortran-do-indent 2)
(setq fortran-if-indent 2)
(setq fortran-structure-indent 2)
(setq fortran-continuation-indent 2)
(setq f90-do-indent 2)
(setq f90-if-indent 2)
(setq f90-structure-indent 2)
(setq f90-continuation-indent 2)
(setq f90-type-indent 2)
#+END_SRC

** Declaration align

Align variable declaration. Key binding is *C-c C-i*.

#+BEGIN_SRC emacs-lisp
(defun my-f90-align-declare ()
  "Align declaration of Fortran variables. The declaration before align
should have \"::\" and \"!\". Declaration like these are valid:

integer :: i ! an integer
type(SomeType) :: atype ! object of SomeType"
  (interactive)
  (let ((begin (region-beginning))
        (end (region-end)))
    (indent-region begin end)
    (align-regexp begin end "\\(\\s-*\\)::" 1 1 nil)
    (align-regexp begin end "::\\(\\s-*\\)" 1 1 nil)
    (align-regexp begin end "\\(\\s-*\\)!" 1 1 nil)))
(eval-after-load "f90"
  `(define-key f90-mode-map (kbd "C-c C-i") 'my-f90-align-declare))
#+END_SRC

** Fortran join lines

#+BEGIN_SRC emacs-lisp
(defun my-f90-join-lines ()
  (interactive)
  (if (region-active-p)
      (let* ((beg (region-beginning))
             (end (region-end))
             (nlines (1- (count-lines beg end)))
             arg)
        (when (= beg (point))
          (setq arg t))
        (dotimes (var nlines)
          (f90-join-lines arg)))
    (f90-join-lines t)))
(evil-define-key 'normal f90-mode-map
  "J" 'my-f90-join-lines)
#+END_SRC

** Some commands
1. f90-end-of-block
2. f90-beginning-of-block
3. ...
** F90 eldoc

#+begin_src emacs-lisp
(autoload 'f90-turn-on-eldoc-mode "f90-eldoc" "Turn on f90 eldoc mode" t)
#+end_src

** F90 expand region

#+begin_src emacs-lisp
(defun f90-mark-block ()
  (interactive)
  (let (reach-beg reach-end)
    (setq reach-beg (f90-reach-beg-of-block))
    (if (region-active-p)
        (progn
          (exchange-point-and-mark)
          (setq reach-end (f90-reach-end-of-block))
          (exchange-point-and-mark))
      (setq reach-end (f90-reach-end-of-block)))
    (unless (region-active-p)
      (set-mark (point)))
    (cond ((and reach-beg reach-end)
           (exchange-point-and-mark)
           (f90-end-of-block)
           (exchange-point-and-mark)
           (f90-beginning-of-block))
          ((and reach-beg (not reach-end))
           (exchange-point-and-mark)
           (f90-end-or-next-block)
           (exchange-point-and-mark))
          ((and (not reach-beg) reach-end)
           (f90-beg-or-prev-block))
          (t
           (f90-beg-or-prev-block)
           (exchange-point-and-mark)
           (f90-end-or-next-block)
           (exchange-point-and-mark)))))

(defun f90-reach-beg-of-block ()
  (interactive)
  (and
   (looking-at
    (format "\\([a-zA-Z0-9_]+[ \t]*:[ \t]*\\)?%s" f90-blocks-re))
   (looking-back "^[ \t]*")))

(defun f90-reach-end-of-block ()
  (interactive)
  (and
   (looking-at "[ \t]*$")
   (looking-back
    (format "end[ \t]*%s\\([ \t]+[a-zA-Z0-9_]+\\)?" f90-blocks-re))))

(defun f90-beg-or-prev-block ()
  (interactive)
  (cond ((f90-reach-beg-of-block)
         (f90-beginning-of-block))
        ((save-excursion
           (beginning-of-line)
           (looking-at
            (format "[ \t]*\\([a-zA-Z0-9_]+[ \t]*:[ \t]*\\)?%s" f90-blocks-re)))
         (back-to-indentation))
        (t
         (f90-beginning-of-block))))

(defun f90-end-or-next-block ()
  (interactive)
  (cond ((f90-reach-end-of-block)
         (f90-end-of-block))
        ((save-excursion
           (beginning-of-line)
           (looking-at (format "[ \t]*end[ \t]*%s" f90-blocks-re)))
         (end-of-line))
        (t
         (f90-end-of-block))))
#+end_src
