#+TITLE: Starter Kit Bindings
#+OPTIONS: toc:nil num:nil ^:nil

This is part of the [[file:starter-kit.org][Emacs Starter Kit]].

* Starter Kit Bindings

Key Bindings.

** Incremental search
*** Use regexp search by default
+ *C-s* to repeat search
+ *C-y* to yank and *M-y* to cycle kill ring
+ *C-o* to call occur
#+begin_src emacs-lisp
(global-set-key (kbd "C-s") 'isearch-forward-regexp)
(global-set-key (kbd "\C-r") 'isearch-backward-regexp)
(global-set-key (kbd "C-M-s") 'isearch-forward)
(global-set-key (kbd "C-M-r") 'isearch-backward)
#+end_src

*** Activate occur easily inside isearch
#+begin_src emacs-lisp
  (define-key isearch-mode-map (kbd "C-o")
    (lambda () (interactive)
      (let ((case-fold-search isearch-case-fold-search))
        (occur (if isearch-regexp
                   isearch-string
                 (regexp-quote isearch-string))))))
#+end_src

*** Isearch yank do what I mean

1. *C-w* is originally bound to =isearch-yank-word-or-char= which incrementally
   yank thing after cursor. This is always not I mean. What I want is to yank
   selected region or symbol at point. This can also mimic
   [[help:highlight-symbol-at-point][highlight-symbol-at-point]].
2. Append thing at point or active region to =regexp-search-ring= and use
   *M-n* to recover it in minibuffer.

#+begin_src emacs-lisp
(defun isearch-yank-dwim ()
  (interactive)
  (isearch-yank-string
   (if (region-active-p)
       (buffer-substring (region-beginning) (region-end))
     (thing-at-point-no-properties'symbol))))
(define-key isearch-mode-map (kbd "C-w") 'isearch-yank-dwim)

(defadvice isearch-forward-regexp (before ifr-ring-before activate)
  (let (thing)
    (setq thing
          (if (region-active-p)
              (buffer-substring-no-properties
               (region-beginning)
               (region-end))
            (thing-at-point-no-properties 'symbol)))
    (when thing
      (setq regexp-search-ring (append regexp-search-ring `(,thing))))))

(defadvice isearch-backward-regexp (before ibr-ring-before activate)
  (let (thing)
    (setq thing
          (if (region-active-p)
              (buffer-substring-no-properties
               (region-beginning)
               (region-end))
            (thing-at-point-no-properties 'symbol)))
    (when thing
      (setq regexp-search-ring (append regexp-search-ring `(,thing))))))
#+end_src

*** Pinyin search

#+begin_src emacs-lisp
(define-key isearch-mode-map "\C-p" #'isearch-toggle-pinyin)
#+end_src

** Hungry delete

#+begin_src emacs-lisp
(require 'hungry-delete)
(mapc
 (lambda (map)
   (define-key map [backspace] 'hungry-backspace))
 `(,prog-mode-map
   ,org-mode-map
   ,text-mode-map))
(eval-after-load "cc-mode"
  `(define-key c-mode-base-map [backspace] 'hungry-delete))
#+end_src

** Move beginning of line

This function is copied form prelude. The differences are:
+ It moves to previous char position of indentation instead of
  indentation. This favors inserting new word at beginning of line.
+ If there is no white space between indentation and beginning, create a white
  space and go to beginning of line.

#+begin_src emacs-lisp
(defun move-beginning-of-line-dwim (arg)
  "Move point to previous char position of indentation or beginning of line."
  (interactive "^p")
  (setq arg (or arg 1))
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))
  (let ((orig-point (point)))
    (back-to-indentation)
    (when (looking-back "[ \t]+" (line-beginning-position))
      (backward-char 1))
    (when (= orig-point (point))
      (if (and
           (looking-back "^" (line-beginning-position))
           (looking-at "[^ \t\n]")
           (not buffer-read-only))
          (progn
            (insert " ")
            (backward-char 1))
        (move-beginning-of-line 1)))))
(global-set-key [remap move-beginning-of-line] 'move-beginning-of-line-dwim)
#+end_src
** Text scale

#+begin_src emacs-lisp
(global-set-key (kbd "C-+") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)
#+end_src
** Org mode

#+begin_src emacs-lisp
(define-key global-map "\C-cl" 'org-store-link)
(define-key global-map "\C-ca" 'org-agenda)
(global-set-key "\C-cc" 'org-capture)
(global-set-key "\C-cj" 'org-clock-goto)
#+end_src

** Upper case word or symbol

#+begin_src emacs-lisp
(define-key global-map (kbd "M-u")
  (lambda (arg)
    (interactive "P")
    (cond ((equal arg '(4))
           (let ((b (bounds-of-thing-at-point 'word)))
             (upcase-region (car b) (cdr b))))
          (arg
           (upcase-word arg))
          (t
           (let ((b (bounds-of-thing-at-point 'symbol)))
             (upcase-region (car b) (cdr b)))))))
#+end_src

** Expand region

#+BEGIN_QUOTE
Expand region increases the selected region by semantic units. Just keep
pressing the key until it selects what you want.
#+END_QUOTE

In terminal, *C-=* may not work. You may have to run extended-command-history
to expand or contract region.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-=") 'er/expand-region)
#+END_SRC

** Run shell command asynchronously by default

#+begin_src emacs-lisp :tangle no
(global-set-key (kbd "M-!") 'async-shell-command)
#+end_src

** Key Chord mode

Use *jk* key chord to quite everything.
#+begin_src emacs-lisp
(require 'key-chord)
(eval-after-load 'evil
  `(progn
     (key-chord-define evil-insert-state-map "jk" 'evil-normal-state)
     (key-chord-define evil-normal-state-map "jk" 'keyboard-quit)
     (key-chord-define evil-visual-state-map "jk" 'keyboard-quit)))
(key-chord-define minibuffer-local-map "jk" 'minibuffer-keyboard-quit)
(key-chord-define minibuffer-local-ns-map "jk" 'minibuffer-keyboard-quit)
(key-chord-define minibuffer-local-completion-map "jk" 'minibuffer-keyboard-quit)
(key-chord-define minibuffer-local-must-match-map "jk" 'minibuffer-keyboard-quit)
(key-chord-define minibuffer-local-isearch-map "jk" 'minibuffer-keyboard-quit)
(key-chord-mode 1)
#+end_src

** Super TAB for program modes

#+begin_src emacs-lisp
(setq ac-dwim nil)
;; don't let ac auto start
(setq ac-auto-start nil)
;; so `yas-expand' will return nil if not expanded
(setq yas-fallback-behavior 'return-nil)
;; so snippet can be triggered inside snippet
(setq yas-triggers-in-field t)

(defun tab-for-anything ()
  "Try to `yas-expand', `auto-complete-1', `yas-next-field',
`indent-according-to-mode'."
  (interactive)
  (let* ((bnds (bounds-of-thing-at-point 'symbol))
         (b0 (car bnds))
         (b1 (cdr bnds))
         (p (point)))
    (cond ((and yas-minor-mode
                b0
                b1
                (<= (- p b0) 2)
                (= p b1)
                (yas-expand)))
          ((and auto-complete-mode
                b0
                b1
                (= p b1)
                (auto-complete-1)))
          ((and yas-minor-mode
                (yas--snippets-at-point))
           (when (and (looking-back " ")
                      (looking-at "[\]\}\)\n\[\(\{ ]"))
             (delete-backward-char 1))
           (yas-next-field))
          (t
           (indent-according-to-mode)))))

(defun ac-refresh-candidates ()
  "Refresh `ac-candidates' and expand common part."
  (interactive)
  (ac-update t)
  (ac-expand-common)
  (when (eq 1 (length ac-candidates))
    (ac-abort)))

(defun prog-mode-setup-tab ()
  (define-key yas-minor-mode-map (kbd "<tab>") nil)
  (define-key yas-minor-mode-map (kbd "TAB") nil)
  (define-key yas-keymap [(tab)] nil)
  (define-key yas-keymap (kbd "TAB") nil)
  (define-key ac-completing-map "\t" 'ac-refresh-candidates)
  (define-key ac-completing-map [tab] 'ac-refresh-candidates)
  (define-key ac-mode-map (read-kbd-macro "TAB") 'tab-for-anything))

(add-hook 'prog-mode-hook 'prog-mode-setup-tab)
#+end_src
