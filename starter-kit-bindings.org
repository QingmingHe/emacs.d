#+TITLE: Starter Kit Bindings
#+OPTIONS: toc:nil num:nil ^:nil

This is part of the [[file:starter-kit.org][Emacs Starter Kit]].

* Starter Kit Bindings

Key Bindings.

** You know, like Readline.
#+begin_src emacs-lisp
(global-set-key (kbd "C-M-h") 'backward-kill-word)
#+end_src

** Align your code in a pretty way.
#+begin_src emacs-lisp
(global-set-key (kbd "C-x \\") 'align-regexp)
#+end_src

** Completion that uses many different methods to find options.

I NEVER use hippie.
#+begin_src emacs-lisp
(global-set-key (kbd "M-/") 'hippie-expand)
#+end_src

** Turn on the menu bar for exploring new modes
#+begin_src emacs-lisp
(global-set-key [f1] 'menu-bar-mode)
#+end_src

** Incremental search

*** Use regexp search by default
+ *C-s* to repeat search
+ *C-y* to yank and *M-y* to cycle kill ring
+ *C-o* to call occur
#+begin_src emacs-lisp
(global-set-key (kbd "C-s") 'isearch-forward-regexp)
(global-set-key (kbd "\C-r") 'isearch-backward-regexp)
(global-set-key (kbd "C-M-s") 'isearch-forward)
(global-set-key (kbd "C-M-r") 'isearch-backward)
#+end_src

*** Activate occur easily inside isearch
#+begin_src emacs-lisp
  (define-key isearch-mode-map (kbd "C-o")
    (lambda () (interactive)
      (let ((case-fold-search isearch-case-fold-search))
        (occur (if isearch-regexp
                   isearch-string
                 (regexp-quote isearch-string))))))
#+end_src

*** Isearch yank do what I mean

1. *C-w* is originally bound to =isearch-yank-word-or-char= which incrementally
   yank thing after cursor. This is always not I mean. What I want is to yank
   selected region or symbol at point.
2. Append thing at point or active region to =regexp-search-ring= and use
   *M-n* to recover it in minibuffer.

#+begin_src emacs-lisp
(defun isearch-yank-dwim ()
  (interactive)
  (isearch-yank-string
   (if (region-active-p)
       (buffer-substring (region-beginning) (region-end))
     (thing-at-point-no-properties'symbol))))
(define-key isearch-mode-map (kbd "C-w") 'isearch-yank-dwim)

(defadvice isearch-forward-regexp (before ifr-ring-before activate)
  (let (thing)
    (setq thing
          (if (region-active-p)
              (buffer-substring-no-properties
               (region-beginning)
               (region-end))
            (thing-at-point-no-properties 'symbol)))
    (when thing
      (setq regexp-search-ring (append regexp-search-ring `(,thing))))))

(defadvice isearch-backward-regexp (before ibr-ring-before activate)
  (let (thing)
    (setq thing
          (if (region-active-p)
              (buffer-substring-no-properties
               (region-beginning)
               (region-end))
            (thing-at-point-no-properties 'symbol)))
    (when thing
      (setq regexp-search-ring (append regexp-search-ring `(,thing))))))
#+end_src

** File finding
#+begin_src emacs-lisp
(global-set-key (kbd "C-x M-f") 'ido-find-file-other-window)
(global-set-key (kbd "C-x C-p") 'find-file-at-point)
(global-set-key (kbd "C-c y") 'bury-buffer)
(global-set-key (kbd "C-x C-f") 'ido-find-file)
(global-set-key (kbd "C-c r") 'revert-buffer)
(global-set-key (kbd "M-`") 'file-cache-minibuffer-complete)
(global-set-key (kbd "C-x C-b") 'ibuffer)
(global-set-key (kbd "C-x f") 'recentf-ido-find-file)
#+end_src

** Indentation help
#+begin_src emacs-lisp
(global-set-key (kbd "C-x ^") 'join-line)
#+end_src

** If you want to be able to M-x without meta
#+begin_src emacs-lisp
(global-set-key (kbd "C-x C-m") 'execute-extended-command)
#+end_src

** Help should search more than just commands
#+begin_src emacs-lisp
  (global-set-key (kbd "C-h a") 'apropos)
#+end_src

** Rgrep
Rgrep is infinitely useful in multi-file projects.

(see [[elisp:(describe-function 'rgrep)]])

#+begin_src emacs-lisp
  (define-key global-map "\C-x\C-r" 'rgrep)
#+end_src

** Hungry delete

#+begin_src emacs-lisp
(mapc
 (lambda (map)
   (define-key map [backspace] 'hungry-backspace))
 `(,prog-mode-map
   ,c-mode-base-map
   ,org-mode-map
   ,text-mode-map))
#+end_src

** Kill and yank

You can also use *M-w* =kill-ring-save=.
#+begin_src emacs-lisp
(global-set-key (kbd "C-c k") 'copy-region-as-kill)
#+end_src

** Move beginning of line

This function is copied form prelude. The differences are:
+ It moves to previous char position of indentation instead of
  indentation. This favors inserting new word at beginning of line.
+ If there is no white space between indentation and beginning, create a white
  space and go to beginning of line.

#+begin_src emacs-lisp
(defun move-beginning-of-line-dwim (arg)
  "Move point to previous char position of indentation or beginning of line."
  (interactive "^p")
  (setq arg (or arg 1))
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))
  (let ((orig-point (point)))
    (back-to-indentation)
    (when (looking-back "[ \t]+" (line-beginning-position))
      (backward-char 1))
    (when (= orig-point (point))
      (if (and
           (looking-back "^" (line-beginning-position))
           (looking-at "[^ \t\n]"))
          (progn
            (insert " ")
            (backward-char 1))
        (move-beginning-of-line 1)))))
(global-set-key [remap move-beginning-of-line] 'move-beginning-of-line-dwim)
#+end_src
