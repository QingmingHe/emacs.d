#+TITLE: Emacs Starter Evil
#+OPTIONS: toc:2 num:nil ^:nil

* Starter Kit Evil

Evil is an evil mode to imitate Vim in Emacs. Starter Kit will set global evil
mode if starter-kit-evil is activated.

** Undo and goto-chg is needed by evil
#+BEGIN_SRC emacs-lisp
(setq undo-tree-visualizer-timestamps t)
(setq undo-tree-visualizer-diff t)
(require 'undo-tree)
(global-undo-tree-mode)
(require 'goto-chg)
#+END_SRC

** Evil leader

#+BEGIN_QUOTE
Evil Leader provides the /leader/ feature from Vim that provides an easy way
to bind keys under a variable prefix key. For an experienced Emacs User it is
nothing more than a convoluted key map, but for a Evil user coming from Vim it
means an easier start. The default escape is *\*.
#+END_QUOTE

You should enable global-evil-leader-mode before you enable evil-mode,
otherwise evil-leader won't be enabled in initial buffers (*scratch*,
*Messages*, ...)
#+BEGIN_SRC emacs-lisp
(require 'evil-leader)
(global-evil-leader-mode)
#+END_SRC

** Evil mode

Set evil mode globally for that the author is a severe Vim user for the past
several years.
#+BEGIN_SRC emacs-lisp
(setq-default evil-symbol-word-search t)
(require 'evil)
(evil-mode 1)
#+END_SRC

** Evil numbers

#+begin_src emacs-lisp
(define-key evil-normal-state-map (kbd "+") 'evil-numbers/inc-at-pt)
(define-key evil-visual-state-map (kbd "+") 'evil-numbers/inc-at-pt)
(define-key evil-normal-state-map (kbd "-") 'evil-numbers/dec-at-pt)
(define-key evil-visual-state-map (kbd "-") 'evil-numbers/dec-at-pt)
#+end_src

** Ace jump

Just press =SPC-w=, the first character of word where you want to go and select
the pop up character, you can move in Emacs quickly. Press *C-x SPE* to jump
back.
#+BEGIN_SRC emacs-lisp
(setq ace-jump-mode-scope 'window)
(define-key global-map (kbd "C-c SPC") 'ace-jump-mode)
(define-key global-map (kbd "C-x SPC") 'ace-jump-mode-pop-mark)
(with-eval-after-load 'ace-jump-mode
  (ace-jump-mode-enable-mark-sync))
(progn
  (eval-after-load "info"
    '(define-key Info-mode-map "o" 'ace-link-info))
  (eval-after-load "help-mode"
    '(define-key help-mode-map "o" 'ace-link-help))
  (eval-after-load "eww"
    '(progn
       (define-key eww-link-keymap "o" 'ace-link-eww)
       (define-key eww-mode-map "o" 'ace-link-eww))))
#+END_SRC

** Vim Bindings for Different States
*** Insert state map

#+begin_src emacs-lisp
(define-key evil-insert-state-map (kbd "C-e") 'move-end-of-line)
(define-key evil-insert-state-map (kbd "C-y") 'yank)
#+end_src

*** Visual state map

#+begin_src emacs-lisp
(define-key evil-visual-state-map (kbd "v") 'er/expand-region)
#+end_src

*** Normal state map

#+begin_src emacs-lisp
(define-key evil-normal-state-map (kbd "C-e") 'move-end-of-line)
(define-key evil-normal-state-map (kbd "j") 'next-line)
(define-key evil-normal-state-map (kbd "k") 'previous-line)
(define-key evil-normal-state-map (kbd "/") 'isearch-forward-regexp)
(define-key evil-normal-state-map (kbd "?") 'isearch-backward-regexp)
#+end_src

*** Ex completion map

#+begin_src emacs-lisp
(define-key evil-ex-completion-map (kbd "M-p") 'previous-complete-history-element)
(define-key evil-ex-completion-map (kbd "M-n") 'next-complete-history-element)
#+end_src

*** Evil ex cmd

#+begin_src emacs-lisp
(evil-ex-define-cmd "ls" 'ibuffer)
#+end_src

** Key bindings with evil leader

+ Universal argument ::
     - '(4): C-u-<SPC>-*
     - other number: <NUMBER>-<SPC>-*

#+BEGIN_SRC emacs-lisp
(evil-leader/set-leader "<SPC>")
(evil-leader/set-key

  ;; fold and unfold
  "zz" (lambda ()
         "Toggle fold all lines larger than indentation on current line. Learn
from http://stackoverflow.com/questions/1587972/how-to-display-indentation-guides-in-emacs."
         (interactive)
         (let ((col 1))
           (save-excursion
             (back-to-indentation)
             (setq col (1+ (current-column)))
             (set-selective-display
              (if selective-display nil (or col 1))))))
  "zo" (lambda ()
         (interactive)
         (cond (outline-minor-mode (show-entry))
               (hs-minor-mode (hs-show-block))))
  "zO" (lambda ()
         (interactive)
         (cond (outline-minor-mode (show-all))
               (hs-minor-mode (hs-show-all))))
  "zc" (lambda ()
         (interactive)
         (cond (outline-minor-mode (hide-entry))
               (hs-minor-mode (hs-hide-block))))
  "zC" (lambda ()
         (interactive)
         (cond (outline-minor-mode (hide-body))
               (hs-minor-mode (hs-hide-all))))

  ;; multiple shell
  "mn" 'multi-eshell-switch
  "me" 'multi-eshell

  ;; tags
  ;; to force update etags cache of helm-tags, type C-u-<SPC>-t-a
  "ta" (lambda (arg)
         (interactive "P")
         (if (project-root-data :use-gtags project-details)
             ;; for some reason `exit' symbol should be `catch' TODO
             (catch 'exit
               (helm-gtags-select))
           (helm-etags-select arg)))
  "dta" 'helm-gtags-dwim
  "rta" 'helm-gtags-find-rtag
  "at" (lambda ()
         (interactive)
         (if (project-root-data :use-gtags project-details)
             (helm-gtags-pop-stack)
           (pop-tag-mark)))
  "ota" 'helm-org-agenda-files-headings
  "tl" (lambda ()
         (interactive)
         (cond ((eq major-mode 'org-mode)
                (helm-org-in-buffer-headings))
               (t (call-interactively 'helm-imenu))))
  "sw" 'helm-swoop
  "oc" 'occur-dwim

  ;; buffers, files
  "bl" 'helm-mini
  "ff" 'ido-find-file
  "ss" (lambda (arg)
         "With prefix ARG, save all buffers and update tags for these files;
otherwise save current buffer."
         (interactive "P")
         (if arg
             (prj/save-buffers-and-update-tags)
           (save-buffer)))
  "kk" 'kill-this-buffer
  "pp" 'prj/helm-mini
  "gs" 'magit-status
  "gr" (lambda ()
         "Run `prj/grep' if a project root is found; otherwise run `rgrep'."
         (interactive)
         (if project-details
             (call-interactively 'prj/grep)
           (call-interactively 'rgrep)))

  ;; ace jump
  "w" 'ace-jump-word-mode
  "l" 'ace-jump-line-mode

  ;; replace
  "rd" (lambda ()
         (interactive)
         (cond ((eq major-mode 'f90-mode)
                (let ((anzu-replace-at-cursor-thing 'f90-subprogram))
                  (anzu-query-replace-at-cursor-thing)))
               (t
                (anzu-query-replace-at-cursor-thing))))
  "rb" (lambda ()
         (interactive)
         (let ((anzu-replace-at-cursor-thing 'buffer))
           (anzu-query-replace-at-cursor-thing)))

  ;; misc
  "fm" 'flycheck-buffer
  "ne" (lambda ()
         "Go to next error of flycheck. If flycheck is not enabled, enabled it
and then check the buffer. Move to first error if reached last error position
before call this command."
         (interactive)
         (unless flycheck-mode
           (flycheck-mode)
           (flycheck-buffer))
         (let ((pos (flycheck-next-error-pos nil nil))
               (counts (length (flycheck-count-errors flycheck-current-errors))))
           (if pos
               (goto-char pos)
             (if (> counts 0)
                 (progn
                   (goto-char (point-min))
                   (flycheck-next-error))
               (message "No error")))))
  "sd" (lambda ()
         (interactive)
         (if (executable-find "sdcv")
             (call-interactively 'sdcv-search-input)
           (message "sdcv is not installed!")))
  "qr" 'quickrun
  "co" (lambda ()
         "If region is active, comment or un-comment the region; otherwise
comment or un-comment current line."
         (interactive)
         (if (region-active-p)
             (comment-or-uncomment-region (region-beginning) (region-end))
           (comment-or-uncomment-region (line-beginning-position) (line-end-position))))
  "iw" 'flyspell-correct-word-before-point)
#+END_SRC

** Quit by escape

#+begin_src emacs-lisp
(defun minibuffer-keyboard-quit ()
  "Abort recursive edit.
In Delete Selection mode, if the mark is active, just deactivate it;
then it takes a second \\[keyboard-quit] to abort the minibuffer."
  (interactive)
  (if (and delete-selection-mode transient-mark-mode mark-active)
      (setq deactivate-mark t)
    (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
    (abort-recursive-edit)))

(define-key evil-normal-state-map [escape] 'keyboard-quit)
(define-key evil-visual-state-map [escape] 'keyboard-quit)
(define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
#+end_src

** Set initial state
#+BEGIN_SRC emacs-lisp
(mapc
 (lambda (item)
   (evil-set-initial-state (car item) (cdr item)))
 '((minibuffer-inactive-mode  . emacs)
   (grep-mode                 . emacs)
   (compilation-mode          . emacs)
   (taglist-mode              . emacs)
   (w3m-mode                  . emacs)
   (eww-mode                  . emacs)
   (dired-mode                . emacs)
   (wdired-mode               . normal)
   (ibuffer-mode              . emacs)
   (help-mode                 . emacs)
   (Info-mode                 . emacs)
   (occur-mode                . emacs)
   (undo-tree-visualizer-mode . emacs)
   (flycheck-error-list-mode  . emacs)
   (git-commit-mode           . insert)
   (magit-branch-manager-mode . emacs)
   (diff-mode                 . emacs)
   (Man-mode                  . emacs)
   (gud-mode                  . insert)
   (eshell-mode               . insert)
   (shell-mode                . insert)))
#+END_SRC

** Cursor in terminal

+ It's hard to distinguish between insert state and normal state if the cursor
  is a block at both state in terminal. Better to switch to a bar in insert
  state just as in Gui.
+ I've no idea how to determine whether Emacs is running in Mintty and
  Tmux. So if all other conditions are not met, just fallback to
  set-evil-cursor-mintty-tmux or set-evil-cursor-mintty-no-tmux.
+ To change cursor display in terminal:
  #+begin_src sh :tangle no
  echo -ne "\ePtmux;\e\e[3 q\e\\"
  #+end_src
  However, call this command by [[help:call-process][call-process]] or [[help:shell-command][shell-command]] don't work at
  all. [[help:send-string-to-terminal][send-string-to-terminal]] works fine.
#+begin_src emacs-lisp
(defun set-evil-cursor-mintty-tmux ()
  (when (evil-emacs-state-p)
    (send-string-to-terminal "\ePtmux;\e\e[3 q\e\\"))
  (when (evil-insert-state-p)
    (send-string-to-terminal "\ePtmux;\e\e[5 q\e\\"))
  (when (evil-normal-state-p)
    (send-string-to-terminal "\ePtmux;\e\e[1 q\e\\")))

(defun set-evil-cursor-mintty-no-tmux ()
  (when (evil-emacs-state-p)
    (send-string-to-terminal "\e\e[3 q\e\\"))
  (when (evil-insert-state-p)
    (send-string-to-terminal "\e\e[5 q\e\\"))
  (when (evil-normal-state-p)
    (send-string-to-terminal "\e\e[1 q\e\\")))

(unless (display-graphic-p)
  (require 'evil-terminal-cursor-changer)
  (if (not (or
            (etcc--on-xterm?)
            (etcc--on-iterm?)
            (etcc--on-gnome-terminal?)
            (etcc--on-konsole?)))
      (progn
        (remove-hook 'post-command-hook 'etcc--set-evil-cursor)
        (if (etcc--on-tmux?)
            (add-hook 'post-command-hook 'set-evil-cursor-mintty-tmux)
          (add-hook 'post-command-hook 'set-evil-cursor-mintty-no-tmux)))
    (setq evil-visual-state-cursor 'box)
    (setq evil-insert-state-cursor 'bar)
    (setq evil-emacs-state-cursor 'hbar)))
#+end_src
