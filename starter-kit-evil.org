#+TITLE: Emacs Starter Evil
#+OPTIONS: toc:2 num:nil ^:nil

* Starter Kit Evil

Evil is an evil mode to imitate Vim in Emacs. Starter Kit will set global evil
mode if starter-kit-evil is activated.

** Undo and goto-chg is needed by evil
#+BEGIN_SRC emacs-lisp
(require 'undo-tree)
(require 'goto-chg)
(global-undo-tree-mode)
#+END_SRC

** Evil leader

#+BEGIN_QUOTE
Evil Leader provides the /leader/ feature from Vim that provides an easy way
to bind keys under a variable prefix key. For an experienced Emacs User it is
nothing more than a convoluted key map, but for a Evil user coming from Vim it
means an easier start. The default escape is *\*.
#+END_QUOTE

You should enable global-evil-leader-mode before you enable evil-mode,
otherwise evil-leader won't be enabled in initial buffers (*scratch*,
*Messages*, ...)
#+BEGIN_SRC emacs-lisp
(require 'evil-leader)
(global-evil-leader-mode)
#+END_SRC

** Evil mode

Set evil mode globally for that the author is a severe Vim user for the past
several years.
#+BEGIN_SRC emacs-lisp
(setq-default evil-symbol-word-search t)
(require 'evil)
(evil-mode 1)
#+END_SRC

** Evil numbers

#+begin_src emacs-lisp
(define-key evil-normal-state-map (kbd "+") 'evil-numbers/inc-at-pt)
(define-key evil-visual-state-map (kbd "+") 'evil-numbers/inc-at-pt)
(define-key evil-normal-state-map (kbd "-") 'evil-numbers/dec-at-pt)
(define-key evil-visual-state-map (kbd "-") 'evil-numbers/dec-at-pt)
#+end_src

** Go to change

It is so happy to key in *g;* or *C-o* to go to last change and *g* or *C-i*,
to com back.

** Ace jump

Just press =SPC-w=, the first character of word where you want to go and select
the pop up character, you can move in Emacs quickly. Press *C-x SPE* to jump
back.
#+BEGIN_SRC emacs-lisp
(require 'ace-jump-mode)
(require 'ace-link)
(setq ace-jump-mode-scope 'window)
(ace-jump-mode-enable-mark-sync)
(define-key global-map (kbd "C-c SPC") 'ace-jump-mode)
(define-key global-map (kbd "C-x SPC") 'ace-jump-mode-pop-mark)
(ace-link-setup-default)
#+END_SRC

** Vim Bindings for Different States
*** Insert state map

#+begin_src emacs-lisp
(define-key evil-insert-state-map (kbd "C-e") 'move-end-of-line)
(define-key evil-insert-state-map (kbd "C-y") 'yank)
#+end_src

*** Visual state map

#+begin_src emacs-lisp
(define-key evil-visual-state-map (kbd "v") 'er/expand-region)
#+end_src

*** Ex completion map

#+begin_src emacs-lisp
(define-key evil-ex-completion-map (kbd "M-p") 'previous-complete-history-element)
(define-key evil-ex-completion-map (kbd "M-n") 'next-complete-history-element)
#+end_src

*** Evil ex cmd

#+begin_src emacs-lisp
(evil-ex-define-cmd "ls" 'ibuffer)
#+end_src

** Key bindings with evil leader

+ Universal argument ::
     - '(4): C-u-<SPC>-*
     - other number: <NUMBER>-<SPC>-*

#+BEGIN_SRC emacs-lisp
(evil-leader/set-leader "<SPC>")
(evil-leader/set-key
  "<SPC>" 'evil-execute-in-emacs-state
  ;; fold and unfold
  "zo" (lambda ()
         (interactive)
         (cond (outline-minor-mode (show-entry))
               (hs-minor-mode (hs-show-block))))
  "zO" (lambda ()
         (interactive)
         (cond (outline-minor-mode (show-all))
               (hs-minor-mode (hs-show-all))))
  "zc" (lambda ()
         (interactive)
         (cond (outline-minor-mode (hide-entry))
               (hs-minor-mode (hs-hide-block))))
  "zC" (lambda ()
         (interactive)
         (cond (outline-minor-mode (hide-body))
               (hs-minor-mode (hs-hide-all))))

  ;; multiple shell
  "mn" 'multi-eshell-switch
  "me" 'multi-eshell

  ;; tags
  ;; to force update etags cache of helm-tags, type C-u-<SPC>-t-a
  "ta" (lambda (arg)
         (interactive "P")
         (if (project-root-data :use-gtags project-details)
             ;; for some reason `exit' symbol should be `catch' TODO
             (catch 'exit
               (helm-gtags-select))
           (helm-etags-select arg)))
  "dta" 'helm-gtags-dwim
  "rta" 'helm-gtags-find-rtag
  "at" (lambda ()
         (interactive)
         (if (project-root-data :use-gtags project-details)
             (helm-gtags-pop-stack)
           (pop-tag-mark)))
  "ota" 'helm-org-agenda-files-headings
  "tl" (lambda ()
         (interactive)
         (cond ((eq major-mode 'org-mode)
                (helm-org-in-buffer-headings))
               (t (call-interactively 'helm-semantic-or-imenu))))
  "sw" 'helm-swoop
  "oc" 'occur-dwim

  ;; buffers, files
  "bb" 'helm-mini
  "ff" 'helm-find-files
  "ss" 'prj/save-buffers-and-update-tags
  "kk" 'kill-this-buffer
  "pp" 'prj/helm-mini
  "gs" 'magit-status
  "gr" (lambda ()
         "Run `prj/grep' if a project root is found; otherwise run `rgrep'."
         (interactive)
         (if project-details
             (call-interactively 'prj/grep)
           (call-interactively 'rgrep)))

  ;; ace jump
  "w" 'ace-jump-word-mode
  "l" 'ace-jump-line-mode

  ;; misc
  "fm" 'flycheck-buffer
  "ne" (lambda ()
         "Go to next error of flycheck. If flycheck is not enabled, enabled it
and then check the buffer. Move to first error if reached last error position
before call this command."
         (interactive)
         (unless flycheck-mode
           (flycheck-mode)
           (flycheck-buffer))
         (let ((pos (flycheck-next-error-pos nil nil))
               (counts (length (flycheck-count-errors flycheck-current-errors))))
           (if pos
               (goto-char pos)
             (if (> counts 0)
                 (progn
                   (goto-char (point-min))
                   (flycheck-next-error))
               (message "No error")))))
  "sd" (lambda ()
         (interactive)
         (if (executable-find "sdcv")
             (call-interactively 'sdcv-search-input)
           (message "sdcv is not installed!")))
  "qr" 'quickrun
  "sgc" 'anzu-query-replace-regexp
  "co" (lambda ()
         "If region is active, comment or un-comment the region; otherwise
comment or un-comment current line."
         (interactive)
         (if (region-active-p)
             (comment-or-uncomment-region (region-beginning) (region-end))
           (comment-or-uncomment-region (line-beginning-position) (line-end-position))))
  "iw" 'flyspell-correct-word-before-point)
#+END_SRC

** Quit by escape

#+begin_src emacs-lisp
(defun minibuffer-keyboard-quit ()
  "Abort recursive edit.
In Delete Selection mode, if the mark is active, just deactivate it;
then it takes a second \\[keyboard-quit] to abort the minibuffer."
  (interactive)
  (if (and delete-selection-mode transient-mark-mode mark-active)
      (setq deactivate-mark t)
    (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
    (abort-recursive-edit)))

(define-key evil-normal-state-map [escape] 'keyboard-quit)
(define-key evil-visual-state-map [escape] 'keyboard-quit)
(define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
#+end_src

** Set initial state
#+BEGIN_SRC emacs-lisp
(mapc
 (lambda (item)
   (evil-set-initial-state (car item) (cdr item)))
 '((minibuffer-inactive-mode  . emacs)
   (grep-mode                 . emacs)
   (compilation-mode          . emacs)
   (taglist-mode              . emacs)
   (w3m-mode                  . emacs)
   (eww-mode                  . emacs)
   (dired-mode                . emacs)
   (wdired-mode               . normal)
   (ibuffer-mode              . emacs)
   (help-mode                 . emacs)
   (Info-mode                 . emacs)
   (occur-mode                . emacs)
   (undo-tree-visualizer-mode . emacs)
   (flycheck-error-list-mode  . emacs)
   (git-commit-mode           . insert)
   (magit-branch-manager-mode . emacs)
   (diff-mode                 . emacs)
   (Man-mode                  . emacs)
   (gud-mode                  . insert)
   (eshell-mode               . insert)
   (shell-mode                . insert)))
#+END_SRC
