#+TITLE: Starter Kit Dired
#+OPTIONS: toc:nil num:nil ^:nil

* Starter Kit Dired
** How dired presents && Dired+
#+BEGIN_SRC emacs-lisp
;; (setq dired-listing-time-style "--time-style long-iso")
(setq dired-listing-time-style "")
(setq dired-listing-switches
      (concat "-lah1v --group-directories-first " dired-listing-time-style))
(setq dired-hide-details-hide-information-lines nil)
(setq dired-hide-details-hide-symlink-targets nil)
(eval-after-load "dired"
  `(progn
     (require 'dired-tar)
     (require 'dired+)
     ;; Emacs 24.4+
     (when (fboundp 'dired-hide-details-mode)
       (global-dired-hide-details-mode t))))
#+END_SRC

- l: Is the only mandatory one.
- a: Means to list all files.
- h: Human readable sizes, such as M for mebibytes.
- 1v: Affects the sorting of digits, hopefully in a positive way.
- --group-directories-first: self-explanatory, I like to have the directories
  on the top, separate from the files.
- --time-style long-iso: show time like *2015-04-12 10:43*.

I want to know how many files under current directory and human readable
available size. The heading line will not be hided if
[[help:global-dired-hide-details-mode][global-dired-hide-details-mode]] is on.
#+begin_src emacs-lisp
(defun my-count-files-under-dir (dir)
  (let ((file-num 0)
        (dir-num 0)
        (files (directory-files dir nil nil t)))
    (mapc
     (lambda (f)
       (unless (or
                (string= "." f)
                (string= ".." f))
         (if (file-directory-p (expand-file-name f dir))
             (setq dir-num (1+ dir-num))
           (setq file-num (1+ file-num)))))
     files)
    (cons file-num dir-num)))

(defun my-dired-present-heading ()
  (let* ((buffer-read-only nil)
         (num (my-count-files-under-dir "."))
         (file-num (car num))
         (dir-num (cdr num))
         size aline)
    (save-excursion
      (goto-char (point-min))
      (forward-line 1)
      (setq aline
            (buffer-substring-no-properties
             (line-beginning-position) (line-end-position)))
      (when (string-match "total[a-zA-Z ]+\\([0-9\\.]+[KMG]?\\)" aline)
        (setq size (match-string-no-properties 1 aline))
        (delete-region (line-beginning-position) (line-end-position))
        (insert (format
                 "  files: %i directories: %i used: %s available: %.1fG \n"
                 file-num dir-num size
                 (/ (/ (string-to-int (or (get-free-disk-space ".") "0"))
                       1024.0) 1024.0)))))
    (set-buffer-modified-p nil)))

(add-hook 'dired-after-readin-hook #'my-dired-present-heading)
#+end_src

Highlight current line in Dired buffer.
#+begin_src emacs-lisp
(when (display-graphic-p)
  (add-hook 'dired-after-readin-hook #'hl-line-mode))
#+end_src

** Basic settings

#+BEGIN_SRC emacs-lisp
;; try to guess destination
(setq dired-dwim-target t)
;; use the same buffer for viewing dir, instead of spawning many
(put 'dired-find-alternate-file 'disabled nil)
;; copy, remove files asynchronous. It's a pitty that `dired-async` don't
;; support tramp well.
;; (eval-after-load "dired-aux"
;;   '(require 'dired-async))
(setq wdired-allow-to-change-permissions t)
#+END_SRC

** Enhanced Dired key bindings

Key bindings should be set after loading dired+.
#+begin_src emacs-lisp
(defun dired-move-to-first-item ()
  "Move to the first item in current Dired buffer."
  (interactive)
  (goto-char (point-min))
  (while (not (looking-at (concat " *" dired-permission-flags-regexp)))
    (forward-line))
  (dired-move-to-filename))

(defun dired-move-to-last-item ()
  "Move to the last item in current Dired buffer."
  (interactive)
  (goto-char (point-max))
  (while (not (looking-at (concat " *" dired-permission-flags-regexp)))
    (forward-line -1))
  (dired-move-to-filename))

(eval-after-load "dired+"
  `(progn
     (define-key dired-mode-map (kbd "RET")
       (lambda ()
         "If file name at current line in Dired is a directory, visit the
directory in the same Dired buffer; otherwise visit the file in another buffer
with the Dired buffer preserved."
         (interactive)
         (let ((file (dired-get-file-for-visit)))
           (if (file-directory-p file)
               (dired-find-alternate-file)
             (find-file file)))))
     (define-key dired-mode-map (kbd "^")
       (lambda ()
         "Goto parent directory in current Dired buffer with cursor locating
at line of last directory."
         (interactive)
         (let ((last-path default-directory))
           (find-alternate-file "..")
           (dired-goto-file last-path))))
     (define-key dired-mode-map (kbd "j")
       (lambda ()
         "Original `dired-goto-file' can't jump to directory in Dired
buffer. This command uses ido to complete read a file or directory name from
all files and directories under current path and jump to it in current Dired
buffer."
         (interactive)
         (let ((fname (ido-completing-read
                       "Goto file or dir: "
                       (directory-files "."))))
           (cond
            ((string= "." fname)
             (goto-char (point-min))
             (re-search-forward " \\.$" nil t)
             (dired-move-to-filename))
            ((string= ".." fname)
             (goto-char (point-min))
             (re-search-forward " \\.\\.$" nil t)
             (dired-move-to-filename))
            (t
             (dired-goto-file (expand-file-name fname)))))))
     (define-key dired-mode-map (kbd "<f5>") 'dired-hide-details-mode)
     (define-key dired-mode-map (kbd "<") #'dired-move-to-first-item)
     (define-key dired-mode-map (kbd ">") #'dired-move-to-last-item)
     (define-key dired-mode-map (kbd "n")
       (lambda ()
         "Move to next item in Dired."
         (interactive)
         (forward-line)
         (unless (looking-at (concat " *" dired-permission-flags-regexp))
           (dired-move-to-first-item))
         (dired-move-to-filename)))
     (define-key dired-mode-map (kbd "p")
       (lambda ()
         "Move to previous item in Dired."
         (interactive)
         (forward-line -1)
         (unless (looking-at (concat " *" dired-permission-flags-regexp))
           (dired-move-to-last-item))
         (dired-move-to-filename)))))
#+end_src

** Find name Dired

+ Use [[help:find-name-dired][find-name-dired]] instead of [[help:find-dired][find-dired]] for the former's simplicity.
+ By default Emacs will pass *-exec* to find and that makes it very slow. It is
  better to collate the matches and then use *xargs* to run the command. To do
  this instead add this to your =~/.emacs=:
+ You can refer to [[https://github.com/typester/emacs/blob/master/lisp/find-dired.el][find dired source]] to get the description of
  [[help:find-ls-option][find-ls-option]]. In short, [[help:car][car]] of it is passed to *find* and [[help:cdr][cdr]] is to tell
  Dired how to parse the output.
+ From [[http://stackoverflow.com/questions/14602291/dired-how-to-get-really-human-readable-output-find-ls-option][stackoverflow]] you can get the answer to get human readable size and
  align Dired output. It may be a bug of *find-dired.el*.
#+begin_src emacs-lisp
(setq find-ls-option '("-print0 | xargs -0 ls -alhd" . ""))
#+end_src

** Ido Dired and move to file's line

#+begin_src emacs-lisp
(defun ido-dired-dwim ()
  "Call `ido-dired' and move to last file's line in Dired buffer if possible."
  (interactive)
  (let* ((file-name (buffer-file-name))
         (dir-name (if file-name
                       (expand-file-name (file-name-directory file-name))
                     "")))
    (call-interactively 'ido-dired)
    (when (string= dir-name (expand-file-name default-directory))
      (dired-goto-file file-name))))
(define-key global-map (kbd "C-x d") 'ido-dired-dwim)
#+end_src

** Find by pinyin Dired

From [[http://github.com/redguardtoo/find-by-pinyin-dired][find by pinyin dired]]. The variable [[help:fbpd-char-table][fbpd-char-table]] is defined in
pinyin-search library.
#+begin_src emacs-lisp
(defun find-by-pinyin-dired (dir pattern)
  "Search DIR recursively for files/directories matching the PATTERN,
and run Dired on those files.
PATTERN is sequence of first character of PinYin from Chinese file name."
  (require 'pinyin-search)
  (interactive
   "DFind-name (directory): \nsFind-name (first characters of Hanzi Pinyin): ")
  (let ((regexp ".*") str)
    (dotimes (i (length pattern))
      (setq str (nth (- (aref pattern i) 97) fbpd-char-table))
      (setq regexp (concat regexp str ".*")))
    ;; find-lisp-find-dired is a lisp version
    (find-lisp-find-dired dir regexp)))
#+end_src

** Dired sort

#+begin_src emacs-lisp
(defun dired-sort-modify-time ()
  (interactive)
  (dired-sort-other (concat "-laht " dired-listing-time-style)))

(defun dired-sort-creat-time ()
  (interactive)
  (dired-sort-other (concat "-lahct " dired-listing-time-style)))

(defun dired-sort-access-time ()
  (interactive)
  (dired-sort-other (concat "-lahut " dired-listing-time-style)))

(defun dired-sort-size ()
  (interactive)
  (dired-sort-other (concat "-lahS " dired-listing-time-style)))

(defun dired-sort-extension ()
  (interactive)
  (dired-sort-other
   (concat "-lahX --group-directories-first " dired-listing-time-style)))

(defun dired-sort-original ()
  (interactive)
  (dired-sort-other dired-listing-switches))
#+end_src

** Tips
*** key bindings

- *w* copies file name to ring. *C-u 0 w* copies full path.
- *!* run shell command, *&* run shell command synchronously.
- *#* to flag all auto save files for deletion.
- *~* to flag all backup files for deletion.

*** Get full file information
*!* on file and type *stat* command.
