#+TITLE: Starter Kit Coding
#+OPTIONS: toc:nil num:nil ^:nil

* Starter Kit Coding
** Prog mode hooks
A single hook holding those functions which should be run in *every*
code buffer.

We have a number of turn-on-* functions since it's advised that lambda
functions not go in hooks. Repeatedly evaling an add-to-list with a
hook value will repeatedly add it since there's no way to ensure that
a lambda doesn't already exist in the list.

#+name: starter-kit-hook-functions
#+begin_src emacs-lisp
(defvar starter-kit-coding-hook nil
  "Hook that gets run on activation of any programming mode.")

(defun starter-kit-auto-fill ()
  (setq-local comment-auto-fill-only-comments nil)
  (auto-fill-mode t))
(add-hook 'starter-kit-coding-hook 'starter-kit-auto-fill)

(defun starter-kit-turn-on-flyspell ()
  (flyspell-prog-mode))
(add-hook 'starter-kit-coding-hook 'starter-kit-turn-on-flyspell)

(defun starter-kit-turn-on-hs ()
  (hs-minor-mode)
  (when (window-system)
    (hideshowvis-enable)
    (hideshowvis-symbols)))
(add-hook 'starter-kit-coding-hook 'starter-kit-turn-on-hs)

;; Use relative line number. Set linum-relative-current-symbol to be empty
;; string so that linum-relative will show the real line number at current
;; line. Linum mode is too slow.
(defun starter-kit-turn-on-linum ()
  (interactive)
  (make-local-variable 'linum-relative-current-symbol)
  (setq linum-relative-current-symbol "")
  (linum-mode 1))

(setq fic-highlighted-words '("FIXME" "TODO" "BUG" "KLUDGE" "DEBUG"))
(add-hook 'starter-kit-coding-hook 'turn-on-fic-mode)

(defun run-starter-kit-coding-hook ()
  "Enable things that are convenient across all coding buffers."
  (run-hooks 'starter-kit-coding-hook))

(add-hook 'prog-mode-hook 'run-starter-kit-coding-hook)
#+end_src

** Handle parens                                                                :smartparens:

#+srcname: starter-kit-match-parens
#+begin_src emacs-lisp
(require 'smartparens-config)
(show-paren-mode 1)
(smartparens-global-mode t)
(smartparens-global-strict-mode t)
#+end_src

*** CC

Use smartparens to handle curly braces and block comment.
#+begin_src emacs-lisp
(defun sp-cc-block-comment (&rest __ignored)
  (save-excursion
    (forward-line -1)
    (end-of-line)
    (insert "*"))
  (save-excursion
    (insert "\n")
    (indent-according-to-mode))
  (indent-according-to-mode))

(defun sp-cc-var-comment (&rest __ignored)
  (backward-char 1)
  (insert "*< "))

(sp-with-modes '(c-mode c++-mode)
  (sp-local-pair "{" nil :post-handlers '(("||\n[i]" "RET")))
  (sp-local-pair "/*" "*/" :post-handlers '((sp-cc-var-comment "SPC")
                                            (sp-cc-block-comment "RET"))))
#+end_src

*** Minibuffer

#+begin_src emacs-lisp
(defun conditionally-enable-parens-mode ()
  (when (eq this-command 'eval-expression)
    (smartparens-mode 1)
    (define-key sp-pair-overlay-keymap (kbd "C-g") nil)))
(add-hook 'minibuffer-setup-hook 'conditionally-enable-parens-mode)
#+end_src

** Show function name in the header line                                        :which:function:mode:

#+begin_src emacs-lisp
(setq which-func-modes
      '(python-mode c-mode c++-mode f90-mode fortran-mode emacs-lisp-mode
                    org-mode perl-mode ruby-mode scheme-mode
                    rst-mode markdown-mode))
(defun starter-kit-which-func-format ()
  (setq-local which-func-unknown "n/a")
  (setq-local header-line-format
              '((which-func-mode ("" which-func-format " "))))
  (setq-local mode-line-misc-info
              (assq-delete-all 'which-func-mode mode-line-misc-info)))
(defun starter-kit-turn-off-which-func ()
  (setq-local header-line-format nil)
  (setq-local mode-line-misc-info
              (assq-delete-all 'which-func-mode mode-line-misc-info)))
(mapc
 (lambda (mode)
   (add-hook (intern (format "%s-hook" (symbol-name mode)))
             'starter-kit-which-func-format))
 which-func-modes)
(add-hook 'lisp-interaction-mode-hook 'starter-kit-turn-off-which-func t)
(which-function-mode 1)
#+end_src
